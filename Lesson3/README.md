# **😘蓝山工作室2023Java第三节课:面向对象进阶**

# 一 . **面向对象进阶**

在上周我们已经了解了java面向对象的基础部分，面向对象的概念还有面向对象的三大特性（封装，继承，多态），相信大家应该已经比较熟悉了吧。Java的面向对象是很重要的一部分，这节课我们会在上次课的基础之上继续讲解java面向对象的进阶部分。

![ktv_1143927428_bFBJNDZNK2tQNy91TzMyRzdDQ3JUQT09_1572099152247.png](resource.pic%2Fktv_1143927428_bFBJNDZNK2tQNy91TzMyRzdDQ3JUQT09_1572099152247.png)

## 1.**final和static关键字**

### 1.1 **final关键字a**

final关键字代表最终，不可改变的意思，从字面上相信大家大概也能猜测到它的大概使用效果。

#### 1.1.1 **final的主要用法：**

- 可以用来修饰一个类

当final关键字修饰一个类时，格式为：

```Plain
public final class 类名称{
//...
} 
```

含义：当前该类不可有任何子类，即**不能被****继承**

**注意：一个类如果是final修饰的，那么其中所有方法都无法进行覆盖重写（因为没有子类）**

-  可以用来修饰一个方法

当final关键字修饰一个方法时，这个方法就是最终方法，也就是**不能被覆盖重写**。强行覆盖重写就报错。

格式：

```Plaintext
修饰符 final 返回值类型 方法名称（参数列表）{
//方法体
}
```

注意事项:

**对于类和方法来说，abstract关键字（下面会讲到）和final关键字不能同时使用，因为矛盾。**

- 3.还可以用来修饰一个局部变量

**一旦使用final用来修饰****局部变量****，那么这个变量就不能进行更改**

**一次赋值，终生不变，再次赋值相同的值也不可以。**

**对于基本类型来说，不可变说的是变量中的数据不可改变**

**对于引用类型来说，不可变说的是变量中的地址值不可改变**

​        final Student stu =new Student("杨姐姐");        //stu=new Student("赵丽颖");//错误写法，地址值不可改变stu.setName("彬哥哥");//正确写法,对于引用类型来说，不可变说的是变量中的地址值不可改变，地址所指向的数据是可以修改的System.out.println(stu.getName());

- 4.还可以用来修饰一个成员变量

对于成员变量来说，如果使用final关键字修饰，那么这个变量照样不可改变

1.由于成员变量有默认值，所以使用final之后就必须手动赋值，不会再给默认值了。

2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二选其一。

3.必须保障类当中的所有重载的构造方法，都最终会对final的成员变量赋值

#### 1.1.2 **使用final关键字所能带来的好处：**

- final关键字提高了性能。JVM和Java应用都会缓存final变量。使用final关键字，JVM会对方法、变量及类进行优化。
- 创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处，譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等等。

### 1.2 **静态static关键字**

所谓static，就是静态的意思。static关键字主要有以下的一些特点。

1.如果一个成员变量使用static，那么这个变量不再属于对象自己，而是属于所在的类，**多个对象共享一份数据**

典例使用：生成对象个数自动计数器

```Plain
public class Count {
    //静态的全局int类型用于统计该类被实例化的次数public static int count = 0;
    public Count() {
        count++;
        System.out.println("第" + count + "次创建对象！！！");
    }
}
```

2.成员方法使用static修饰，成为了静态方法。**静态方法不属于对象，而属于类**

对于静态方法来说，可以通过对象名调用，也可以通过类名称调用。

但更推荐用类名称调用（毕竟该方法是隶属于整个类的，而不是某个对象）。

**注意事项：**

1.**静态方法****不能直接访问非静态**

原因：因为内存当中是**先有静态（在编译时就已经分配空间了），后才有非静态内容**。

注意：

在程序运行的过程中，static修饰的静态变量和全局变量都是储存在一个叫全局数据区的地方。也并不是说全局变量在定义时加了static关键字才是静态存储，不加static就是动态存储，不是的。不管加不加static，全局变量都是存储在静态存储区的，都是在编译时分配存储空间的，两者只是作用域不同，全局变量默认具有外部链接性，作用域是整个工程，**全局静态变量的作用域仅限本文件，不能在其他文件中引用**

2.**静态方法****当中不可使用this**

原因：this代表当前对象，通过谁调用的方法，谁即为当前对象，但是静态方法并不会属于某个对象，而是属于整个类。

大家看一下这段代码，应该比较熟悉吧(沛沛哥带着大家写的第一个程序Hello World!😍 😍 ）

```Plain
public class Test
{
    public static void main(String[] args)
    {
        System.out.println("(♥◠‿◠)ﾉﾞ  hello world!   ლ(´ڡლ)ﾞ  \n" +
                " .-------.       __             \n" +
                " |  _ _   \\      \\   \\   /  /    \n" +
                " | ( ' )  |       \\  . /  '       \n" +
                " |( o _) /        _( )_ .'         \n" +
                " | (_,_).' __  ___(_ o _)'          \n" +
                " |  |\\ \\  |  ||   |(_,_)'         \n" +
                " |  | \\ '   /|   -'  /           \n" +
                " |  |  \\    /  \\      /           \n" +
                " ''-'   '-'    `-..-'              ");
    }
}
        
```

大家可以看到我们java程序的main函数也是有static关键字修饰的。就简单和大家简单讲一下这里为什么main函数也是静态的。

为什么 main 方法是静态的（static）？

static是静态修饰符，被他修饰的方法我们称之为静态方法，静态方法有一个特点，那就是静态方法独立于该类的任何对象，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。而对于main方法来说，他的调用过程是经历了类加载、链接和初始化的。但是并没有被实例化过，这时候如果想要调用一个类中的方法。那么这个方法必须是静态方法，否则是无法调用的。（简言之，在程序刚刚启动时还不存在任何的对象，此时静态的main方法将执行并构造程序所需要的对象）

#### 1.2.1**静态代码块**

格式：

```Plain
public class 类名称{
  //静态代码块  static{
//静态代码块内容
}
}
```

静态代码块直接写在类当中。

**特点：当第一次执行本类时，静态代码块执行唯一一次**

主要用途：用来一次性地对静态成员变量进行赋值。

#### 1.2.2**使用static关键字的好处：**

- 不需要创建具体的对象，便可以直接调用类当中的静态方法
- 在类中修饰变量时，可以实现同一个类当中的所有对象共享一份数据
- 被static修饰的部分只在类第一次加载时被初始化一次，可以提高程序性能。

## 2.**抽象类**

相信上节课通过熠哥的讲解，大家对抽象类与方法有了深入的了解，在这里我就带大家简单的再复习一下这个概念。

![OIP-C (1).jpg](resource.pic%2FOIP-C%20%281%29.jpg)

抽象类就是被abstract关键字所修饰的类。抽象类里面一般都包含有抽象方法（并不是必须有抽象方法，但是抽象类中不含有抽象方法，那么也就失去了将它定义为抽象类的意义了）。我觉得抽象类其实可以理解成一张不完整的设计图，一般作为父类，让子类来继承。当父类知道子类一定要完成某种行为，但是每个子类该行为的实现又不同，于是该父类就把该行为定义成抽象方法的形式，具体实现交给子类去完成。此时这个类就可以声明成抽象类。

### 2.1 **抽象方法**

抽象方法只有声明，而没有具体的实现，如果**父类****中的方法还不能确定如何具体进行{ }实现**，那么这就应该写成一个抽象方法

- 不能直接创建new 抽象类对象
- 必须用一个子类来继承抽象父类
- 子类必须覆盖重写抽象父类中的所有抽象方法（如果子类没有重写抽象父类的全部抽象方法，则该子类也必须为抽象类）

覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体

- 创建子类对象开始使用

注意事项：

- 抽象类中可以有构造方法，是供子类创建对象时，初始化父类成员使用的。

理解：子类的构造方法中有默认的super（），需要访问父类的构造方法

- 抽象类中，不一定包含抽象方法
- 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则无法通过编译而报错，**除非该子类也是抽象类**

### 2.2**抽象类****与普通的类的不同：**

- 最大的区别主要就是，抽象类不能直接用new关键字进行实例化操作，必须由它的子类来实现该抽象父类的全部抽象方法。
- 抽象类中可以定义不含有方法体的抽象方法，但是抽象方法必须声明为`public`或者`protected`，如果未加任何修饰符则默认为public类型。

抽象类更像是定义了一种规范，只要继承于该抽象类的子类都要按照抽象类中的抽象方法的声明来进行实现。

## 3.**接口 - Interface**

官方解释：Java接口是一系列方法的声明，是一些方法特征的集合，**一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。**

​    我的解释：接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段（大家都知道在我们java中，类是只能进行单继承的，一个类它只能拥有一个父类。为了解决类只能单继承所带来的问题，又引入了接口这个概念，一个类是可以实现多个接口的。），但是接口在实际中更多的作用是制定标准的。**或者我们可以直接把接口理解为100%的****抽象类****，接口中的方法必须全部是抽象方法。（JDK1.8之前可以这样理解）**

### 3.1**接口的定义以及实现：**

为了声明一个接口，我们使用interface这个关键字，在接口中的所有方法都必须只声明方法标识，而不要去声明具体的方法体，因为具体的方法体的实现是由继承该接口的类来去实现的，因此，接口并不用管具体的实现。接口中的属性默认为Public Static Final.一个类实现这个接口必须实现这个接口中定义的所有的抽象方法。

-  一个简单的接口就像这样：拥有全局变量和抽象方法。

```Plain
interface in1{
    //默认前缀为 public static final
    final int a = 10;
    //默认前为public abstract
    //接口中的方法只能声明，具体实现需要在实现接口的类中重写该方法，
    //以此规范某种类的书写
    void display();
}
```

- 为了实现这个接口，我们使用implements关键词去实现接口：

```Plain
class textClass implements in1{
    //继承接口中display的方法，并写明具体实现
    public void display(){
        System.out.println("你好~！，哈↗哈↘");
    }
```

- 其中testClass类实现了我们上面刚才定义的 in1 这个接口，既然你要实现接口，也就是实现接口代表的一种能力，那么你就必须去实现接口给你规定的方法，只有把接口给你规定的抽象方法都给实现了，才承认你这个类实现了这个接口，实现了这个接口代表的某种功能。上图实现了接口中规定的display（）方法。

```Plain
    //测试
    public static void main(string[] args){\
        textClass textclass = new textClass();
        textclass.display();
        System.out.println(a);
    }
 }
```

- 写一个测试类，用来测试一下我们刚才实现的这个接口，因为testclass类的对象t实现了接口规定的display方法，那么自然而然就可以调用display（）方法咯。

```Plain
//最后的输出结果（看看你想通了吗）
你好~！，哈↗哈↘
10
```

### 3.2接口的进一步理解

我们知道，如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法），下面是具体的例子：

先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法

```Java
interface USB {
    //USB最常用的读写方法
    void read();

    void write();
}
```

然后在写一个U盘类和一个键盘类，这两个类都去实现USB接口。（实现其中的方法）

```Java
class computer implements USB {
    @Override
    public void read() {
        System.out.println("电脑正在通过USB功能读取数据");
    }
    @Override
    public void write() {
        System.out.println("电脑正在通过USB功能写入数据");
    }
}
```

这个就是一个接口最常用的功能，不知道你搞懂了吗？

![OIP-C (2).jpg](resource.pic%2FOIP-C%20%282%29.jpg)

### 3.3**接口****回调****:**

接口[回调](https://so.csdn.net/so/search?q=回调&spm=1001.2101.3001.7020)是指：使用某一接口的类创建的对象的引用赋给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口的方法。当接口变量调用被类实现的接口中的方法时，就是通知相应的对象调用接口的方法.

先通过一段演示代码做一个讲解吧

```Plain
interface Fight {
    void beAttacked(Hero hero);
}
//英雄战斗类实现了Fight接口
class HeroFight implements Fight {
    @Override
    public void beAttacked(Hero hero) {
        System.out.println("英雄受到了伤害值");
        hero.setHp(hero.getHp() - 50);
        if (hero.getHp() <= 0) {
            System.out.println("该英雄受到过多伤害，已阵亡。");
            hero.Die();//回调实体类Hero的方法
        }
    }
}
//英雄类class Hero {
    private Integer hp = 100;
    private Boolean isDead = false;
    //战斗的方法
    public void toFight(Fight fight) {
        fight.beAttacked(this);
    }
    public void Die() {
        this.isDead = true;
    }
    public Integer getHp() {
        return hp;
    }
    public void setHp(Integer hp) {
        this.hp = hp;
    }
}
```

在英雄的战斗方法中Fight接口的实现类HeroFight的一个实例对象作为参数传进方法里，调用该类的beAttacked方法，如果hp<=0就会调用英雄的Die方法。回调主要就是体现在beAttacked方法中调用了Hero的Die方法，所以Die方法也就是**回调函数**

## 4.**Lambda表达式**

简单讲一下这个Lambda表达式，Lambda表达式是在java8所新增的新特性。

**其实我感觉这个不太常用，这种表达不是很通俗易，但是写这种代码挺有逼格的。**

lambda表达式允许你通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体(body,可以是一个表达式或一个代码块)。 **Lambda 表达式可以看作是一个****匿名函数**，基于数学中的λ演算得名，也可称为闭包。

换句简单的话说： Lambda表达式允许你直接把一个代码块赋值给一个变量

要了解Lambda表达式,首先需要了解什么是函数式接口，**函数式接口定义：一个接口有且只有一个抽象方法 。**就像上面的演示代码中的Fight接口，就很明显是一个函数式接口。

//有且仅有一个接口interface Fight {    void beAttacked(Hero hero); }

**Lambda表达式****基本语法: (参数) ->表达式 或 (参数) ->{ 语句; }**

```Java
Fight heroFight=(Hero hero)->{
            System.out.println("Lambda表达式调用");
        };
```

## 5.**抽象类****和接口的比较：（重要！！！😡😡😡）**

大家听了抽象类和接口肯定就会产生疑问：

> 学长！既然可以把接口理解为抽象类，那么为什么还要接口这个复杂的东西呢，直接用抽象类不就好了。🤣🤣🤣

接下来我就具体讲一下两者之间的一些区别：

先直接举个例子来帮助大家理解吧：

我们现在要定义鸟的实类，首先最重要考虑的问题是鸟的特性和鸟的行为，鸟的特性我们把它理解为种类，这时我们应该用抽象类首先来定义鸟的大类，并在里面规定一些抽象的方法，这些抽象方法是鸟类都有的，但在不同鸟中又有所不同（比如栖息在树上，但具体位置又不一样）。这时有了鸟的抽象类之后，我们就可以定义不同的具体类例如：麻雀，八哥，燕子等，每一个类表示一种鸟来继承这个鸟的大类（抽象类）。

但鸟除了本身特性以外还有很多行为，例如鸟都会飞，这时我们需要用接口来描述这个飞的行为，然后让每一个鸟的类来实现这个飞的接口，这样鸟就具备了它所有的属性。

**简单来说****抽象类****定义了你是什么，接口规定了你能做什么**

再来看看两者的区别吧

- 抽象类特点

1. 继承了抽象类的子类，要么对父类的抽象方法进行重写，要么自己也是抽象类
2. 抽象类也可以拥有普通方法
3. 抽象类不能创建对象
4. 抽象类也有构造方法，但是是为了子类创建对象使用

- 接口的特点

1. 接口是行为的抽象，是一种行为的规范，接口是like a 的关系；抽象是对类的抽象，是一种模板设计，抽象类是is a 的关系。
2. 接口没有构造方法，而抽象类有构造方法，其方法一般给子类使用
3. 接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
4. 抽象体现出了继承关系，继承只能单继承。接口提现出来了实现的关系，实现可以多实现。接口强调特定功能的实现，而抽象类强调所属关系。
5. 接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。

## 6.**内部类**

如果一个事物内部含有另一个事物，那么这就是一个类内部包含另一个类。

如同身体和心脏的关系

### 6.1**Java中内部类的分类：**

#### **6.1.1成员内部类**

成员内部类的定义格式：

```Plaintext
修饰符 class 外部类名称{
  修饰符 class 成员内部类名称{
     //...
   }
   //...
}
```

**注意：内用外，随意访问；外用内，一定要有内部类对象**

编译后，内部类也会生成一个class文件，且自动命名为**外部类名称$内部类名称**

所以在给类命名的时候不建议使用$符号

成员内部类的使用：

1.间接方式：在外部类的方法中，使用内部类，然后main只是调用外部类方法。

2.直接方式：

**类名称 对象名 = new 类名称（）；**

**外部类名称.内部类名称 对象名 =new 外部类名称（）.new 内部类名称（）；**

成员变量重名时：

如果出现重名现象，那么格式是：外部类名称.this.外部类成员变量

```Java
public class Outer{
int num=10;//外部类成员变量public class Inner{
   int num=20;//内部类成员变量public void methodInner(){
    int num=30;//内部类方法的局部变量System.out.println(num);//局部变量，就近原则System.out.println(this.num);//内部类的成员变量System.out.println(Outer.this.num);//外部类的成员变量
    }
  }
}
```

#### 6.2.**2.局部内部类（包含匿名内部类）**

如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。

“局部”，只有当前所属的方法才能使用它，出了这个方法外面就不能用了

定义格式：

```Java
修饰符 class 外部类名称{
    修饰符 返回值类型 外部类方法名称（参数列表）{
       class 局部内部类名称{
       //....
       }
    } 
}
```

**注意事项：**

局部内部类，如果希望访问所在方法的局部变量，那么 这个局部变量必须是【**有效final的**】

备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略

原因：

1. new 出来的对象在堆内存中
2. 局部变量是跟着方法走，在栈内存中
3. 方法运行结束后，立即出栈，局部变量就会消失
4. 但是new出来的对象会在堆内存中持续存在，直到垃圾回收消失

类的权限修饰符：

定义一个类的时候，权限修饰符规则：

1.外部类：public /（default）

2.成员内部类：public / protected /（default）/ private

3.局部内部类：什么也不能写【效果与（default）不同】

**匿名内部类：**

如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略该类的定义，而改为使用【匿名内部类】，直接new接口或父类

**匿名内部类的定义格式：**

```Java
接口名称 对象名 =new 接口名称（）{
    @Override//覆盖重写所有抽象方法
}；
```

对格式“new 接口名称（）{...}”进行解析

1.new代表创建对象的动作

2.接口名称就是匿名内部类需要实现哪个接口，也可以是抽象父类

3.{......}这才是匿名内部类的内容

另外还要注意几点问题：

1.匿名内部类，在【创建对象】时，只能使用唯一一次。

如果希望多次创建相同对象，还是需要写出具体的实现类来实现接口或者是继承抽象父类。

**匿名内部类所需要注意的事项**

- 匿名内部类中不能存在任何静态成员或方法
- 匿名内部类是没有构造方法的，因为它没有类名
- 与局部内部相同匿名内部类也可以引用局部变量。此变量也必须声明为 final（局部变量与匿名内部类的生命周期不同）（从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略）

![img.png](resource.pic%2Fimg.png)

## **作业：**

Leval1:
复习前两节课内容，自己写一写课件中的代码（无需提交）
Leval2：
来点算法
1.爬楼梯
2.罗马数字转整数
Leval3：
还记得上节课实现的英雄联盟吗：试着完善或重构吧！
这里提供的是一些简单的思路：
角色系统，角色拥有很多属性，角色也可以通过一些其他的方式（比如打怪？）提升类似属性等级啊啥的
装备系统，角色可以通过装备各种装备可以提升对应的数值，装备可以有一定的培养机制。
货币系统，可以让角色通过一些方式收集货币，然后可以通过消费货币提升角色属性，装备那些什么。
这次作业是一个比较开放性的作业，上面也只是提供一点思路，大家有什么自己的想法，也可以自己进行实现。
加分内容：
设计出两个角色的战斗过程，角色与野外小怪的战斗过程
这算是一个综合性比较强的作业，重点在于对类和接口的设计，希望能在完成作业的过程中能对多接口的实现和抽象类的继承还有抽象方法的实现有进一步的理解，大家都尽力完成哟！（对作业的完成度不做强制要求）
