## 蓝山2023Java第六节课

###### 	经过前几周的学习，大家已经对于Java这门语言有了一定的了解，接下来这节课让我们暂时跳出Java，对于后端的一些东西进行讲解。那么在后端，跟我们打交道最多的就是各种各样的数据了，那么这些数据该存储到哪里并且怎么使用呢？接下来这节课我们讲解MySQL和Redis相关的知识。

------

### MySql

#### 数据库

##### 1.什么是数据库

> ###### 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。

##### 2.数据库的分类

* 关系型数据库：关系型数据库指的是使用关系模型（二维表格模型）来组织数据的数据库。
* 非关系型数据库（**NOSQL**）：非关系型数据库又被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定，常用于存储非结构化的数据。

| 大类  |    类别     |                            常见                            |                             说明                             |
| :---: | :---------: | :--------------------------------------------------------: | :----------------------------------------------------------: |
|  SQL  | 关系数据库  |    Oracle、MySQL/MariaDB、SQL Server、PostgrcSQL、 DB2     | 遵循“表一记录”模型。按行存储在文件中(先第 1 行，然后第 2 行……) |
| NoSQL | 时序数据库  |        InfluxDB、RRDtool、Graphite、OpcnTSDB、Kdb+         | 存储时间序列数据，每条记录都带有时间戳。如存储从感应器采集到的数据 |
| NoSQL | 键/值数据库 |       Redis、Memcached、Riak KV、Hazelcast、Ehcache        |          遵循“键——值”模型，是最简单的数据库管理系统          |
| NoSQL | 文档数据库  |  MongoDB、Couchbase、Amazon DynamoDB、CouchDB、MarkLogic   | 无固定结构，不同的记录允许有不同的列数和列类型。列允许包含多值，记录允许嵌套 |
| NoSQL |  图数椐库   |         Neo4j、OrientDB、Titan、Virtuoso、ArangoDB         |           以“点——边”组成的网络（图结构）来存储数据           |
| NoSQL |  搜索引擎   |       Elasticsearch、Solr、Splunk、MarkLogic、Sphinx       |             存储的目的是为了搜索，主要功能是搜索             |
| NoSQL | 对象数据库  | Caché、db4o、Versant Object Database、ObjcctStore、Matisse | 受面向对象编程语言的启发，把数据定义为对象并存储在数据库中，包括对象之问的关系，如继承 |
| NoSQL | 宽列数据库  |                Cassandra、 HBase、Accumulo                 | 按照列（由“键——值”对组成的列表）在数据文件中记录数据，以获得更好的请求及遍历效率。一行中的列数允许动态变化，且列的数目可达数百万，每条记录的关键码不同，支持多值列。 |

##### 3.数据库结构

以关系数据库举例：**关系数据库= 多张表+各表的关系**

>  下面是一个名为`person`的表，

| Id   | LastName | FirstName | Address        | City     |
| ---- | -------- | --------- | -------------- | -------- |
| 1    | Adams    | John      | Oxford Street  | London   |
| 2    | Bush     | George    | Fifth Avenue   | New York |
| 3    | Carter   | Thomas    | Changan Street | Beijing  |

> 各表之间的关系：
>
> **关系就是数据能够对应的匹配，在关系数据库中正式名称叫联结，对应的英文名称叫做join**。

##### 4.什么是SQL

SQL其实是一门结构化查询语言，是用来操作数据库里数据的工具

* DQL 数据查询语言：主要是使用`SELECT`关键字进行各种简单查询，连接查询的操作
* DML 数据操纵语言：主要是用`INSERT` `UPDATE` `DELETE`关键字对数据进行操作
* DDL 数据定义语言：主要是使用`CREATE` `DROP` `ALTER`关键字对逻辑结构等有操作的，包括表结构，索引等
* DCL 数据控制语言：数据控制语言用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。

#### MySQL

1. **版本**

   分为四种：Alpha版、Beta版、RC版(Release Candidate)、GA版(Generally Available)。

   1. **Alpha版**

      Alpha版软件，这是软件工程对软件开发过程软件版本定义使用的版本说明。Alpha是内部测试版,一般不向外部发布,会有很多Bug.除非你也是测试人员,否则不建议使用.是希腊字母的第一位,表示最初级的版本，alpha 就是α。

   2. **Beta版**

      Beta版软件，这也是软件工程中对软件开发测试版本控制的版本说明。Beta一般是Alpha后面的版本。该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一缺陷，需要经过多次测试来进一步消除。这个阶段的版本会一直加入新的功能。beta 就是β。

   3. **RC版**

      RC版，RC即Release Candidate的简写。这是Beta后面的版本，一般RC版并没有新增功能，而是修复了一些反馈的Beta中存在的BUG。所以RC版更接近最终发行版即稳定版(GA版)

   4. **GA版**

      GA版，GA即Generally Available的简写。这就是软件最终的发行版。这个版本一般BUG相对较少。这个发行版也可以叫稳定版。

   5. **Release版**

      Release版，在有些软件存在，在MySQL中一般没有这个版本。该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。

2. **分支**

   不同公司对数据库的需求不同，如功能，性能等，因此诞生了不同的MySQL分支。

   市面上流行的分支：Oracle公司官方版MySQL、**Percona Server、Maria DB**

   简单来说大家需要知道的是：

   **Percona公司更偏向于运维工具；Maria DB更偏向于功能的完善；Oracle MySQL它介于两者之间**。

3. **版本号**

   推荐主流版本号：**5.7**和**8.0**这两个大版本的数据库

   求稳定建议5.7系列，如果想尝鲜直接上车8.0

##### 1.MySQL 安装

自行搜索教程进行安装

**注意** 如果在过程中想卸载MySQL，请去网上搜索卸载流程，不是简单删除就可以了。

##### 图形化管理界面：

1. **MySQL Workbench、**
2. **phpMyAdmin、**
3. **Navicat、** **推荐**
4. **MySQL Dumper、**
5. **SQLyog、**
6. **MySQL ODBC Connector、**
7. **Data grip**

------

##### 2.MySQL常用语法以及sql操作

1. 登录mysql

   ```mysql
   mysql -uroot -p
   ```

2. 查看所有数据库

   ```mysql
   show databases
   ```

3. 使用某个库

   ```
   use 库名
   ```

4. 查看当前库的所有表

   ```mysql
   show tables
   ```

5. 查看库的所有表

   ```mysql
   show tables from 数据库
   ```

6. 创建表

   ```
   create table 表名（
   列名 列类型，
   列名 列类型，
   ........
   );
   ```

7. 清除表数据

   ```
   TRUNCATE TABLE 表名称
   ```

8. 删除表

   ```
   DROP TABLE 表名称
   ```

9. 插入数据

   ```
   INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....);
   ```

10. 更改数据

   ```
   UPDATE 表名称 SET 列名=？？？ WHERE 列名=？？？
   ```

11. 删除数据

    ```
    DELETE FROM 表名称 WHERE 列名=？？？
    ```

12. 查看表结构

    ```
    DESC 表名称
    ```

13. 查看服务器版本

    ```
    SELECT VERSION
    ```

14. 查看字符集

    ```
    show variables like 'character_%';
    show character set;
    select * from information_schema.character_sets;
    ```

15. 查询数据

16. 查询单表中全部数据

    ```
    select * from 表名称
    ```

17. 条件查询

    ```
    select * from 表名 where 列名=??? 
    ```

18. 范围查询

    ```
     select * from 表名 where 列名 between 40 and 50
    ```

19. 离散查询

    ```
    elect * from 表名 where 列名 （not） in (' ',' ',' ')
    ```

20. 模糊查询

    ```
    select * from 表名 where 列名 like '%A%'——查包含A的 
    select * from 表名 where 列名 like 'A**%'——查以A开头的 
    select * from 表名 where 列名 like '%**A'——查以A结尾的 
    select * from 表名 where 列名 like 'A'——查等于A的 
    select * from 表名 where 列名 like '__E'——查第三个是E的 % 代表是任意多个字符
    ```

21. 排序查询

    ```
    select * from 表名 order by 列名 (desc) 默认升序排列
    ```

22. 分页查询

    ```
     select * from 表名 limit x(起始索引),y(记录条数);
    ```

23. 去重操作

    ```
    select distinct 列名 from 表名
    ```

24. 分组查询

    ```
    select 字段1，字段2 from 表名 group by 字段1，字段2... // 没有group by 默认分成一组
    
    having //针对于group by 使用过滤 在where无法完成时才使用 用法和where一样
    ```

25. 统计查询（聚合函数）

    ```
     select count (*) from 表名——查询所有数据条数（每一列的） 
     select count (列名主键) from 表名——查询这列的所有数据条数（执行快） 
     select sum (列名) from 表名——求和 
     select avg (列名) from 表名——求平均值 
     select max (列名) from 表名——求最大值 
     select min (列名) from 表名——求最小值
    ```

26. 子查询

1. where语句中的子查询 **where语句中不能使用分组函数 如min()**

   ```mysql
   select name
   from student
   where age>(select min(age) from student);
   ```

2. from语句中的子查询

   ```mysql
   select t1.company_id,t1.company_name,t1.department_id,t2.department_name
   from company t1,
   (select * from department where department_name like '%T%')t2 
   --子查询作为表放在from 后面
   where t1.department_id=t2.department_id;
   ```

27. 多表查询

1. 内连接查询

   ```mysql
   --隐式内连接
   select 字段列表 from 表1，表2 where 筛选条件 ;
   --显式内连接
   select 字段列表 from 表1 【inner】 join 表2 on 连接条件 ... ;
   ```

2. 外连接查询

   ```
   --左外连接
   select  字段列表  
   from  表1  
   left 【outer】 join  表2  
   on  条件...
   --右外连接
   select  字段列表  
   from  表1  
   right 【outer】 join  表2  
   on  条件...
   ```

3. 自连接查询

   ```
   --自连接表一定要起别名
   select  字段列表  
   from  表1  as 别名1  
   join 表1  as 别名2  
   on 条件...
   ```

   **注意：对于多表联查使用join时，我们一般用小表在前后表在后，用小表牵引大表去查询**

##### 3.MySQL规范：

* 不区分大小写，一般关键字大写，表名，列名大写
* 注意换行或缩进
* 注释：单行注释 #注释文字 /-- 注释文字 多行注释 /* */

##### 4.索引（index）

索引是对数据库表中一列或多列的值进行排序的一种结构。MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。

**优点**：

- 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 索引可以帮助服务器避免排序和创建临时表
- 索引可以将随机IO变成顺序IO

**缺点：**

- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
- 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大
- 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度

##### 5.约束

###### 一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性。MySQL数据库通过约束(`constraints`)防止无效的数据进入到表中，以保护数据的实体完整性。

分类：

* `NOT NULL`：非空约束，用于约束该字段的值不能为空。比如姓名、学号等。

* `DEFAULT`：默认值约束，用于约束该字段有默认值，约束当数据表中某个字段不输入值时，自动为其添加一个已经设置好的值。比如性别。

* `PRIMARY KEY`：主键约束，用于约束该字段的值具有唯一性，至多有一个，可以没有，并且非空。比如学号、员工编号等。

  ```mysql
  create table t vip (
  id int,
  name varchar (255),
  email varchar (255) ,
  unique ( name，email)
  );
  ```

  

* `UNIQUE`：唯一约束，用于约束该字段的值具有唯一性，可以有多个，可以没有，可以为空。比如座位号。

* `CHECK`：检查约束，用来检查数据表中，字段值是否有效。比如年龄、性别。（mysql不支持，oracle支持）

* `FOREIGN KEY`：外键约束，外键约束经常和主键约束一起使用，用来确保数据的一致性，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值。在从表添加外键约束，用于引用主表中某列的值。比如学生表的专业编号，员工表的部门编号，员工表的工种编号。

##### 6.字符集

字符集规定了**规定了字符在数据库中的存储格式，比如占多少空间，支持哪些字符等等。不同的字符集有不同的编码规则，在有些情况下，甚至还有校对规则的存在**。所以我们在使用数据库使要选择合适的字符集编码，否则可能会出现乱码现象，接下来使一些常见的字符集：

| 字符集  | 长度 | 说明                                    |
| ------- | ---- | --------------------------------------- |
| GBK     | 2    | 支持中文，但是不是国际通用字符集        |
| UTF-8   | 3    | 支持中英文混合场景，是国际通用字符集    |
| latin1  | 1    | MySQL默认字符集                         |
| utf8mb4 | 4    | 完全兼容UTF-8，用四个字节存储更多的字符 |

一般来说我们都选择utf8或者utf8mb4进行编码。

##### 7.存储引擎

1.**存储引擎是什么**

存储引擎就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。

##### 2.MySQL中常见的存储引擎

* **InnoDB**： 支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。
* **MyISAM**： 插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用。
* **MEMORY**： 所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。

| 特性           | InnoDB | MyISAM | MEMORY |
| -------------- | ------ | ------ | ------ |
| 事务安全       | 支持   | 无     | 无     |
| 存储限制       | 64TB   | 有     | 有     |
| 空间使用       | 高     | 低     | 低     |
| 内存使用       | 高     | 低     | 高     |
| 插入数据的速度 | 低     | 高     | 高     |
| 对外键的支持   | 支持   | 无     | 无     |

##### 8.事务

1.什么是事务

数据库中的事务是指对数据库执行一批操作，在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。

- 事务是一个原子操作。是一个最小执行单元。可以甶一个或多个SQL语句组成
- 在同一个事务当中，所有的SQL语句都成功执行时，整 个事务成功，有一个SQL语句执行失败，整个事务都执行失败。

2.特性

* 原子性：事务的整个过程如原子操作一样，最终要么全部成功，或者全部失败，这个原子性是从最终结果来看的，从最终结果来看这个过程是不可分割的。

* 一致性：一个事务必须使数据库从一个一致性状态变换到另一个一致性状态。

* 隔离性: 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

  隔离级别：

  * **读未提交**：read uncommitted （最低隔离级别） 事务A可以读取到事务B未提交的数据。 这种隔离级别存在的问题就是: 脏读现象 (Dirty Read) 我们称读到了脏数据。 这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步
  * **读已提交**：read committed 事务A只能读取到事务B提交之后的数据， 解决了脏读的现象。但是不可重复读取数据。 在事务开启后，第一读到3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，3<>4，称为不可重复读取
  * **可重复读**：repeatable read 事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读 ，可以会出现幻读。mysql默认的事务隔离级别就是这个！！
  * **序列化**：serializable 这是最高隔离级别，效率最低。解决所有问题 这种隔离级别表示事务排队，不能并发！ synchronized，线程同步（事务同步） 每一次读取到的数据都是真实的，并且效率是最低的。

* 持久性：一个事务一旦提交，他对数据库中数据的改变就应该是永久性的。当事务提交之后，数据会持久化到硬盘，修改是永久性的。

3.事务相关问题

* 脏读
* 幻读
* 不可重复读

### Redis

------

#### 1.Redis是什么

Redis，即远程字典服务 Redis是一个**key-value** 存储系统 Redis 通常被称为数据结构服务器，因为值（value）可以是字符串(String)、哈希(Hash)、列表(list)、集合(sets)和有序集合(sorted sets)等类型。

#### 2.Redis有什么用

在Java Web中主要的两个用处

- 存储 **缓存** 用的数据；
- 需要高速读/写的场合**使用它快速读/写**；

#### 3.缓存

在实际操作过程中，我们读比写的操作一般都是要多很多的，当我们使用SQL语句进行读写操作时，数据库会去磁盘索引数据，这个过程是比较慢的，这个时候我们就需要缓存这样的操作。

如果我们把数据放在 Redis 中，也就是直接放在内存之中，让服务端**直接去读取内存中的数据**，那么这样速度明显就会快上不少，并且会极大减小数据库的压力，但是使用内存进行数据存储开销也是比较大的，限于成本的原因，一般我们**只是使用 Redis 存储一些常用和主要的数据**。

读取操作

![img](https://image-9h8.pages.dev/file/ac849c6711975b011f26b.png)



通过上图我们能看出来

1. 当**第一次读取数据的时候**，读取 Redis 的数据就会失败，此时就会触发程序读取数据库，把数据读取出来，并且写入 Redis 中；
2. 当**第二次以及以后需要读取数据时**，就会直接读取 Redis，读到数据后就结束了流程，这样速度就大大提高了。

写操作的流程：

![](https://image-9h8.pages.dev/file/9e2de8ddca840ed37d2e9.png)

从流程可以看出，更新或者写入的操作，需要多个 Redis 的操作，如果业务数据写次数远大于读次数那么就没有必要使用 Redis。

在使用redis进行缓存时，要考虑以下几个方面:

* **业务数据常用吗？命中率如何？**如果命中率很低，就没有必要写入缓存；
* **该业务数据是读操作多，还是写操作多？**如果写操作多，频繁需要写入数据库，也没有必要使用缓存；
* **业务数据大小如何？**如果要存储几百兆字节的文件，会给缓存带来很大的压力，这样也没有必要；

#### 4.高速读/写场合

###### 在日常生活中，高并发的现象更多了，比如在双十一的时候，在一个时间段会有很多不同的请求到达服务器，如果都直接去操作数据库，很可能会处理的太慢甚至崩掉。

![img](https://image-9h8.pages.dev/file/94068da5357515895379d.png)

1. 当一个请求到达服务器时，只是把业务数据在 Redis 上进行读写，而没有对数据库进行任何的操作，这样就能大大提高读写的速度，从而满足**高速响应的需求**；
2. 但是这些缓存的数据仍然需要持久化，也就是存入数据库之中，所以在一个请求操作完 Redis 的读/写之后，会去**判断该高速读/写的业务是否结束**，这个判断通常会在秒杀商品为0，红包金额为0时成立，如果不成立，则不会操作数据库；如果成立，则触发事件将 Redis 的缓存的数据以批量的形式**一次性写入数据库**，从而完成持久化的工作。

#### 5.数据类型

> redis是一种key:value存储数据，对于key来说，尽量选择一个统一的命名格式，放到一个工具类里面，尽量不要出现魔法值。

##### 1.字符串(string)

String是 Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。 String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M

##### 常用命令

1. set ：set 设置相同的key将覆盖先前的值
2. get ：get
3. append 将给定的value追加到原值的末尾。
4. strlen 获得值的长度
5. setnx 只有在key 不存在时才设置key的值,存在时不设置
6. incr 将key中储存的数字值增1 只能对数字值操作，如果为空，新增值为1
7. decr 将key 中储存的数字值减1 只能对数字值操作，如果为空，新增值为-1
8. incrby / decrby key 步长 将key中储存的数字值增减。自定义步长。
9. mset .... 同时设置一个或多个key-value对r
10. mget ..... 同时获取一个或多个value
11. msetnx .... 同时设置一个或多个key-value对，当且仅当所有给定key都不存在
12. getrange <起始位置><结束位置> 获得值的范围，类似java中的substring,前包，后包
13. setrange <起始位置> 用覆写所储存的字符串值，从<起始位置>开始（索引从0开始）。
14. setex 设置键值的同时，设置过期时间，单位秒。

##### 2.列表(list)

redis中的lists在底层实现上并不是数组，而是链表，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。

**常用命令**

1. lpush/rpush …从左边/右边插入一个或多个值。
2.  lpop/rpop 从左边/右边吐出一个值。值在键在，值光键亡。
3.  rpop/lpush 从列表右边吐出一个值，插到列表左边。 
4. Irange 按照索引下标获得元素（从左到右） Irange 0 -1 0左边第一个，-1右边第一个 (0 -1表示获取所有) 
5. lindex 按照索引下标获得元素（从左到右） 
6. len 获得列表长度

##### 3.集合

redis的集合，是一种无序的集合，集合中的元素没有先后顺序。

集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。

**常用命令**

1. sadd .... 将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略
2. smembers取出该集合的所有值。
3. sismember 判断集合是否为含有该值，有1，没有0，
4. scard 返回该集合的元素个数。
5. srem ..删除集合中的某个元素。
6. spop 随机从该集合中吐出一个值。
7. srandmember 随机从该集合中取出n个值。不会从集合中删除
8. smovevalue把集合中一个值从一个集合移动到另一个集合
9. sinter返回两个集合的交集元素。
10. sunion返回两个集合的并集元素。
11. sdif返回两个集合的差集元素(key1中的，不包含key2中的)

##### 4.哈希

Redis 的哈希是键值对的集合。
Redis 的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象，还有用户信息之类的，经常变动的信息。
Hash更适合用于对象的存储，String更适合字符串存储。

**常用命令**

1. hset 给集合中的键赋值
2. hget 从集合取出value
3. hmset ... 批量设置hash的值
4. hexists查看哈希表key中，给定域field是否存在。
5. hkeys 列出该hash集合的所有field
6. hvals 列出该hash集合的所有value
7. hincrby .为哈希表key中的域feld的值加上增量1 -1
8. hsetnx .将哈希表key中的域field的值设置为value,、当且仅当域field不存在

##### 5.有序集合

redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。

很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等集合的成员是唯一的，但是评分可以是重复了。因为元素是有序的,所以你也可以很快的根据评分( score )或者次序( position )来获取一个范围的元素。访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表

**常用命令**

1. zadd .... 将一个或多个member元素及其score值加入到有序集key当中。
2. zrange [withscores] 返回有序集key中，下标在 之间的元素带WITHSCORES,可以让分数一起和值返回到结果集。
3. zrangebyscore key minmax [withscores] [limit offset count] 返回有序集key中，所有score值介于min和max之间（包括等于min或max)的成员。有序集成员按score值递增（从小到大）次序排列。
4. zrevrangebyscore key maxmin [withscores] [limit offset count]

#### 6.持久化

redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。

RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；

AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。

其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。

如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。

##### 1.RDB

RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。

redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。

对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。

如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。

虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。

##### 2.AOF

AOF，英文是Append Only File，即只允许追加不允许改写的文件。

如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍。

因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。

在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。

虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。

#### 7.主从复制

像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。

主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。

redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。

主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。

#### 8.集群操作

单实例存Redis缓存会存在的几个问题：

（1）写并发：

​    Redis单实例读写分离可以解决读操作的负载均衡，但对于写操作，仍然是全部落在了master节点上面，在海量数据高并发场景，一个节点写数据容易出现瓶颈，造成master节点的压力上升。

（2）海量数据的存储压力：

​    单实例Redis本质上只有一台Master作为存储，如果面对海量数据的存储，一台Redis的服务器就应付不过来了，而且数据量太大意味着持久化成本高，严重时可能会阻塞服务器，造成服务请求成功率下降，降低服务的稳定性。

 Redis集群采用去中心化的思想，没有中心节点的说法，对于客户端来说，整个集群可以看成一个整体，可以连接任意一个节点进行操作，就像操作单一Redis实例一样，不需要任何代理中间件，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node。

#### 9.缓存穿透、缓存击穿、缓存雪崩

##### 1.缓存穿透

缓存和数据库中都没有的数据，可用户还是源源不断的发起请求，导致每次请求都会到数据库，从而压垮数据库。

##### 解决方法：

* 业务层校验

用户发过来的请求，根据请求参数进行校验，对于明显错误的参数，直接拦截返回。

比如，请求参数为主键自增id，那么对于请求小于0的id参数，明显不符合，可以直接返回错误请求。

* 不存在数据设置短过期时间

对于某个查询为空的数据，可以将这个空结果进行Redis缓存，但是设置很短的过期时间，比如30s，可以根据实际业务设定。注意一定不要影响正常业务。

* 采用布隆过滤器

  将存在的key保存在布隆过滤器中，并让布隆过滤器作为第一层访问拦截，当验证所要查询的数据存在时，才能继续到缓存层中查询。

##### 2.缓存击穿

Redis中一个热点key在失效的同时，大量的请求过来，从而会全部到达数据库，压垮数据库。

##### 解决方法：

* 设置热点数据永不过期

对于某个需要频繁获取的信息，缓存在Redis中，并设置其永不过期。当然这种方式比较粗暴，对于某些业务场景是不适合的。

* 定时更新

比如这个热点数据的过期时间是1h，那么每到59minutes时，通过定时任务去更新这个热点key，并重新设置其过期时间。

* 互斥锁

这是解决缓存穿透比较常用的方法。

互斥锁简单来说就是在Redis中根据key获得的value值为空时，先锁上，然后从数据库加载，加载完毕，释放锁。若其他线程也在请求该key时，发现获取锁失败，则睡眠一段时间（比如100ms）后重试。

##### 3.缓存雪崩

Redis中缓存的数据大面积同时失效，或者Redis宕机，从而会导致大量请求直接到数据库，压垮数据库。

##### 解决方法：

* 设置有效期均匀分布

避免缓存设置相近的有效期，我们可以在设置有效期时增加随机值；

或者统一规划有效期，使得过期时间均匀分布。

* 数据预热

对于即将来临的大量请求，我们可以提前走一遍系统，将数据提前缓存在Redis中，并设置不同的过期时间。

* 保证Redis服务高可用

前面我们介绍过Redis的哨兵模式和集群模式，为防止Redis集群单节点故障，可以通过这两种模式实现高可用。 　　
